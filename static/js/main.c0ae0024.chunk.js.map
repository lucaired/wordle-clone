{"version":3,"sources":["WordGrid.js","Keyboard.js","App.js","reportWebVitals.js","index.js"],"names":["Letter","props","letter","style","background","color","animation","fontWeight","border","fontSize","height","width","WordGrid","words","display","gridGap","justifyContent","justifyItems","map","word","flexDirection","columnGap","Word","KeyboardButtonRow","letters","colorCoding","buttonHandler","KeyboardButton","buttonStyle","backgroundColor","lineHeight","onClick","Keyboard","letterButtonHandler","enterButtonHandler","delButtonHandler","useState","setColorCoding","useEffect","buildColorMapping","newColorCoding","emptyGrid","forEach","label","newColor","hasOwnProperty","oldColor","undefined","slice","marginRight","marginLeft","App","chosenWord","setChosenWord","hideNotInWordList","setHideNotInWordList","hideWinnerNotification","setHideWinnerNotification","chooseWord","wordlist","Math","floor","random","length","toUpperCase","console","log","initializeWords","Array","fill","setWords","currentIndex","setCurrentIndex","Toast","hide","text","borderRadius","padding","zIndex","className","borderBottom","paddingBottom","rowGap","newWords","letterObj","join","includes","toLowerCase","i","setTimeout","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.c0ae0024.chunk.js","sourcesContent":["function Word(props) {\n    /**\n     * This component display a word. \n     */\n\n    const { word } = props\n\n    return <div \n            style={{\n                display: 'flex',\n                flexDirection: 'row',\n                columnGap: '5px'\n            }}\n            >\n        {word.map((letter) => {\n            return <Letter letter={letter} />\n        })}\n    </div>\n}\n\nfunction Letter(props) {\n    /**\n     * This component display a single letter. If the letter has a \n     * color coding there will be a animation.\n     */\n    const { letter } = props\n    return <span\n            style={{\n                background: letter.color,\n                color: letter.color ? 'white' : 'black',\n                animation: letter.color ? '1s ease 0s 1 normal none running colorChange' : 'none',\n                fontWeight: 'bold',\n                border: '1px solid grey',\n                fontSize: '5vw',\n                height: '8vw',\n                width: '8vw',\n            }}\n        >{letter.letter}\n        </span>\n}\n\nfunction WordGrid(props) {\n    /**\n     * This components display the letters of last row, each letter\n     * also has a color coding. Here current letters have no color,\n     * green letters are in the correct place, orange somewhere in the \n     * word and grey letters are not in the word. If the letter has a \n     * color coding there will be a animation.\n     */\n    const { words } = props\n    \n    return <div style={{\n        display: 'grid',\n        gridGap: '5px',\n        justifyContent: 'center',\n        justifyItems: 'center'\n    }}>\n        {words.map((word) => Word({word}))}\n    </div>\n}\n\nexport default WordGrid","import { useEffect, useState } from \"react\"\n\nfunction KeyboardButtonRow(props) {\n    /**\n     * Returns a row of buttons.\n     */\n\n    const { letters, colorCoding, buttonHandler } = props\n\n    return <div style={{\n        display: 'flex',\n        flexDirection: 'row',\n        columnGap: '5px',\n    }}>\n        {letters.map((letter) => {\n            return <KeyboardButton \n                        letter={letter} \n                        color={colorCoding[letter]} \n                        buttonHandler={buttonHandler}\n                        buttonStyle={{}}\n                    />\n        })}\n    </div>\n}\n\nfunction KeyboardButton(props) {\n    /**\n     * Returns a letter button.\n     */\n    \n    // Detructure props in letter, color and buttonHandler\n    const { letter, color, buttonHandler, buttonStyle } = props\n\n    return <button \n            style={{ \n                backgroundColor: color,\n                fontSize: '4vw',\n                lineHeight: '4vw',\n                ...buttonStyle \n            }} \n            onClick={() => buttonHandler(letter)}\n        >\n            {letter}\n        </button>\n}\n\nfunction Keyboard(props) {\n    /**\n     * Returns the button beign pressed and takes a color-coding for the buttons.\n     */\n    \n    // Detructure props in buttonHandler and colorCoding\n    const { letterButtonHandler, enterButtonHandler, delButtonHandler, words } = props\n\n    const [colorCoding, setColorCoding] = useState({})\n    \n    useEffect(()=> {\n        buildColorMapping(words)\n    }, [words])\n\n    // Create a list of letters\n    const letters = ['Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P', 'A', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L', 'Z', 'X', 'C', 'V', 'B', 'N', 'M']\n\n    const buildColorMapping = (words) => {\n        /**\n         * Green always dominates, orange only grey. This function processes\n         * changes to the words and updates the colorCoding. It will update\n         * the colorCoding only if the new color is green or orange and the\n         * old color is grey. If no color has been assigned to a letter it\n         * will not be updated. Also if no previous colors have been assigned\n         * the new color will be assigned. Furthermore, if all letters are ' '\n         * the colorCoding will be reset.\n         */\n\n        let newColorCoding = {}\n        let emptyGrid = true\n        words.forEach((word) => {\n            word.forEach((letter) => {\n                const label = letter['letter']\n                // If we encounter a non-empty letter, we know that the grid is not empty                \n                if (label !== ' ') {\n                    emptyGrid = false\n                }\n                \n                const newColor = letter['color']\n                \n                if (colorCoding.hasOwnProperty(label)) {\n                    const oldColor = colorCoding[label]\n                    if (newColor === 'green') {\n                        newColorCoding[label] = newColor\n                    }\n                    else if (oldColor === 'grey' && newColor === 'orange') {\n                        newColorCoding[label] = newColor\n                    }\n                }\n                else {\n                    if (newColor !== undefined) {\n                        newColorCoding[label] = newColor\n                    }\n                }\n            })\n        })\n        if (emptyGrid) {\n            setColorCoding({})\n        } else {\n            setColorCoding(colorCoding => {\n                return {...colorCoding, ...newColorCoding}\n            })\n        }\n    }\n\n    return <div>\n        <div style={{\n            display: 'grid',\n            gridGap: '5px',\n            justifyContent: 'center',\n            justifyItems: 'center'\n        }}>\n            <KeyboardButtonRow \n                letters= {letters.slice(0,10)}\n                colorCoding={colorCoding}\n                buttonHandler={letterButtonHandler}\n            />\n            <KeyboardButtonRow \n                letters= {letters.slice(10, 19)} \n                colorCoding={colorCoding}\n                buttonHandler={letterButtonHandler}\n            />\n            <div style={{\n                display: 'flex',\n                flexDirection: 'row'\n            }}>\n                <KeyboardButton \n                    letter={'Enter'} \n                    color={{}} \n                    buttonHandler={enterButtonHandler}\n                    buttonStyle={{marginRight: '5px'}}\n                />\n                <KeyboardButtonRow \n                    letters= {letters.slice(19)} \n                    colorCoding={colorCoding}\n                    buttonHandler={letterButtonHandler}\n                />\n                <KeyboardButton \n                    letter={'Del'} \n                    color={{}} \n                    buttonHandler={delButtonHandler}\n                    buttonStyle={{marginLeft: '5px'}}\n                />\n            </div>\n        </div>\n    </div>\n}\n\nexport default Keyboard","import React, { useEffect, useState } from 'react';\n\nimport './App.css';\nimport wordlist from './wordlist.json';\nimport WordGrid from './WordGrid';\nimport Keyboard from './Keyboard';\n\nfunction App() {\n\n  const [chosenWord, setChosenWord] = useState(\"\")\n  const [hideNotInWordList, setHideNotInWordList] = useState(true)\n  const [hideWinnerNotification, setHideWinnerNotification] = useState(true)\n\n  const chooseWord = () => {\n    const chosenWord = wordlist[Math.floor(Math.random() * wordlist.length)].toUpperCase()\n    console.log(chosenWord)\n    setChosenWord(chosenWord)\n  }\n\n  useEffect(() => chooseWord(), [])\n\n  /**\n   * This is the main component of the app. \n   * It contains the WordGrid and the Keyboard.\n   */\n\n  const initializeWords = () => Array(6).fill().map(() => Array(5).fill({letter: ' '}))\n  const resetWords = () => { setWords(initializeWords()); setCurrentIndex([0,0]) }\n  const [words, setWords] = useState(initializeWords())\n  /**\n   * The current index of the word grid. We will increment the inner\n   * index if there is still place in the word. The outer index\n   * will be incremented if the user presses enter and the current\n   * word is in our list of words. Furthermore, the del button will\n   * decrement the inner index if it is not 0.\n   * \n   */\n  const [currentIndex, setCurrentIndex] = useState([0,0])\n\n  const letterButtonHandler = (letter) => {\n    /**\n     * This function is called when a letter button is pressed. \n     * It will add the letter to the current word and increment\n     * the current index. If the current word is full, it will\n     * no longer increment the inner index and will not add the\n     * letter to the word.\n     */\n\n    let newWords = [...words]\n    if (currentIndex[0] < newWords.length && \n        currentIndex[1] < newWords[currentIndex[0]].length) {\n          newWords[currentIndex[0]][currentIndex[1]] = { letter: letter }\n          setWords(newWords)\n          setCurrentIndex([currentIndex[0], currentIndex[1] + 1])\n    }\n  }\n\n  const delButtonHandler = () => {\n    if (currentIndex[0] < words.length && \n        currentIndex[1] > 0 &&\n        currentIndex[1] <= words[currentIndex[0]].length) {\n          let newWords = [...words]\n          newWords[currentIndex[0]][currentIndex[1] - 1]['letter'] = ' '\n          setWords(newWords)\n          setCurrentIndex([currentIndex[0], currentIndex[1] - 1])\n        }\n  }\n\n  const currentWord = () => words[currentIndex[0]].map((letterObj) => letterObj.letter).join('')\n\n  const enterButtonHandler = () => {\n    if (currentIndex[0] < words.length && \n        currentIndex[1] === words[currentIndex[0]].length) {\n          const word = currentWord()\n          if (wordlist.includes(word.toLowerCase())) {\n\n            let newWords = [...words]\n\n            for (let i = 0; i < word.length; i++) {\n              if (word[i] === chosenWord[i]) {\n                newWords[currentIndex[0]][i]['color'] = 'green'\n              }\n              else if (chosenWord.includes(word[i])) {\n                newWords[currentIndex[0]][i]['color'] = 'orange'\n              }\n              else {\n                newWords[currentIndex[0]][i]['color'] = 'grey'\n              }\n            }\n            setCurrentIndex([currentIndex[0] + 1, 0])\n            setWords(newWords)\n\n            if (chosenWord === word) {\n              setHideWinnerNotification(false)\n              setTimeout(() => {\n                resetWords()\n                setHideWinnerNotification(true)\n                chooseWord()\n              }, 5000)\n            }\n          } else {\n            setHideNotInWordList(false)\n            setTimeout(() => {\n              setHideNotInWordList(true)\n            }, 500)\n          }\n    }\n  }\n\n  const Toast = (props) => {\n    // How to wrap the text in CSS so that it takes only the width of the word\n    const { hide, backgroundColor, text } = props\n    return <p \n      style={{\n          color: 'white',\n          border: '1px solid black',\n          borderRadius: '5px',\n          backgroundColor: backgroundColor,\n          display: hide ? 'none' : 'inline-block',\n          padding: '1vw',\n          fontWeight: 'bold',\n          zIndex: '100',\n        }}>\n          {text}\n        </p> \n  }\n\n  /** TODO: coding\n   * - refactor the code so that there is only one toast component\n   * - add a timer to the toast component, showing it for 5000ms\n   * - add a listener to keydown that passes the uppercase of a letter input to the letterButtonHandler\n   * - update React deps\n   * \n\n  /* TODO: styling\n    - centralize the letter in the word grid\n    - use a toast to show the user that the word is not in the word list\n    - adapt font size to the screen size\n    - shake the keyboard when the user presses enter on a word that is not in the word list\n  */\n\n  return (\n    <div className=\"App\">\n      <h1 style={{\n        borderBottom: '1px solid black',\n        fontSize: '6vw',\n        paddingBottom: '30px',\n      }}>\n        Wordle\n      </h1>\n      <div \n        // Style the container, so that the Keyboard is at the bottom\n        style={{\n          display: 'flex',\n          flexDirection: 'column',\n          justifyContent: 'space-between',\n          rowGap: '10px',\n        }}\n        >\n        <WordGrid\n          words={words}\n        />\n        <Keyboard\n          letterButtonHandler={letterButtonHandler}\n          enterButtonHandler={enterButtonHandler}\n          delButtonHandler={delButtonHandler}\n          words={words}\n        />\n      </div>\n      <Toast\n        hide={hideNotInWordList}\n        backgroundColor='black'\n        text='Not in word list'\n      />\n      <Toast\n        hide={hideWinnerNotification}\n        backgroundColor='green'\n        text='You won!'\n      />\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}